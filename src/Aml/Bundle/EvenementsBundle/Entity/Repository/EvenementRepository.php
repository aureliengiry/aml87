<?php

namespace Aml\Bundle\EvenementsBundle\Entity\Repository;

use Doctrine\ORM\EntityRepository;

/**
 * Evenement
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class EvenementRepository extends EntityRepository
{
	/**
     * Fonction pour avoir les prochains évènements
     * 
     * @param int $id_communaute
     * @param int $limit
     * @return ArrayCollection
     */
	public function getEvenementsCalendar( $dateStart, $dateEnd )
	{
		$dateTimeStart = new \DateTime();
		$dateTimeStart->setTimestamp($dateStart);
		
		$dateTimeEnd = new \DateTime();
		$dateTimeEnd->setTimestamp($dateEnd);
		
		$q = $this->getEntityManager()->createQueryBuilder();		
		$q
			 ->select('e')
			 ->from('AmlEvenementsBundle:Evenement', 'e')
			 ->where('e.dateStart > :dateStart')
			// ->andWhere('e.date_start < :date_end')
			 ->orderBy('e.dateStart', 'ASC')
			 ->setParameters(array
				 (
					'dateStart' => $dateTimeStart,
					//'date_end' => $dateTimeEnd,
				 ));

			
	    return $q->getQuery()->getResult();
	}

    /**
     * Function to build request in order to filter blog articles
     *
     * @param $query
     * @param array $params
     * @param array $filters
     * @return mixed
     */
    private function _buildRequestByFilters( $query, $params = array(), $filters = array() ){
        if( isset($filters['archive']) ){
            $query
                ->andWhere("e.archive = :archive")
            ;
            $params['archive'] = $filters['archive'];
        }

        if( isset($filters['public']) ){
            $query
                ->andWhere("e.public = :public")
            ;
            $params['public'] = $filters['public'];
        }
        if( isset($filters['type']) && !empty($filters['type']) ){
            $query
                ->andWhere("e.type = :type")
            ;
            $params['type'] = $filters['type'];
        }

        $query->setParameters( $params );

        return $query;
    }

	/**
     * Fonction pour avoir les prochains évènements
     * 
     * @param int $id_communaute
     * @param int $limit
     * @return ArrayCollection
     */
	public function getNextEvenements( $filters = array() )
	{
		$dateTimeStart = new \DateTime();
		$dateTimeStart->setTime(0,0);
		
		$q = $this->getEntityManager()->createQueryBuilder();		
		$q
			 ->select('e')
			 ->from('AmlEvenementsBundle:Evenement', 'e')
			 ->where('e.dateStart >= :dateStart')
			 ->orderBy('e.dateStart', 'ASC')
        ;

        if( !empty($filters) ){
            if( isset($filters['dateStart']) && !empty($filters['dateStart']) )
            {
                $params = array
                (
                    'dateStart' => $filters['dateStart'],
                );
            }
            else{
                $params = array
                (
                    'dateStart' => $dateTimeStart,
                );
            }


            $q = $this->_buildRequestByFilters( $q,$params, $filters );
        }
        else{
            $q->setParameters(array
            (
                'dateStart' => $dateTimeStart,
            ));
        }

        $query =  $q->getQuery();
        //var_dump('<pre>', $query->getSQL(),$queryParameters,$queryParameters[0],$filters);exit;
	    return $query->getResult();
	}

    /**
     * Fonction pour avoir les prochains évènements
     *
     * @param int $id_communaute
     * @param int $limit
     *
     * @return ArrayCollection
     */
    public function getNextConcert()
    {
        $currentDate = new \DateTime();
        $currentDate->setTime(0, 0);

        $q = $this->getEntityManager()->createQueryBuilder();
        $q
            ->select('e')
            ->from('AmlEvenementsBundle:Evenement', 'e')
            ->where('e.dateStart >= :currentDate')
            ->orderBy('e.dateStart', 'ASC')
            ->setMaxResults(1);

        $params = array(
            'currentDate' => $currentDate,
        );

        $filters = array(
            'type' => \Aml\Bundle\EvenementsBundle\Entity\Evenement::EVENEMENT_TYPE_CONCERT,
            'archive' => 0,
            'public' => 1
        );

        $q = $this->_buildRequestByFilters($q, $params, $filters);

        $query = $q->getQuery();

        try {
            return $query->getSingleResult();
        }
        catch(\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }
}